-- This script was generated by the Schema Diff utility in pgAdmin 4. 
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated 
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps. 
 -- BEGIN; 
create extension hstore;
 CREATE TABLE IF NOT EXISTS public.user_state
(
    id serial NOT NULL,
    user_id integer NOT NULL,
    estado_id character(2) COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp(6) without time zone DEFAULT now(),
    updated_at timestamp without time zone,
    CONSTRAINT pkey_user_state PRIMARY KEY (id),
    CONSTRAINT user_state_estado_id_fkey FOREIGN KEY (estado_id)
        REFERENCES public.cne_estados (estado_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT user_state_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.user_state
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.logged_actions
(
    id serial NOT NULL,
    schema_name text COLLATE pg_catalog."default" NOT NULL,
    table_name text COLLATE pg_catalog."default" NOT NULL,
    relid oid NOT NULL,
    session_user_name text COLLATE pg_catalog."default",
    ci_usuario text COLLATE pg_catalog."default",
    nombre_usuario text COLLATE pg_catalog."default",
    action_tstamp_tx timestamp with time zone NOT NULL,
    action_tstamp_stm timestamp with time zone NOT NULL,
    action_tstamp_clk timestamp with time zone NOT NULL,
    transaction_id bigint,
    application_name text COLLATE pg_catalog."default",
    client_addr text COLLATE pg_catalog."default",
    client_port integer,
    client_query text COLLATE pg_catalog."default",
    action text COLLATE pg_catalog."default" NOT NULL,
    row_data hstore,
    changed_fields hstore,
    statement_only boolean NOT NULL,
    CONSTRAINT logged_actions_pkey PRIMARY KEY (id),
    CONSTRAINT logged_actions_action_check CHECK (action = ANY (ARRAY['I'::text, 'D'::text, 'U'::text, 'T'::text]))
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.logged_actions
    OWNER to postgres;

COMMENT ON TABLE public.logged_actions
    IS 'History of auditable actions on audited tables, from if_modified_func()';

COMMENT ON COLUMN public.logged_actions.id
    IS 'Unique identifier for each auditable event';

COMMENT ON COLUMN public.logged_actions.schema_name
    IS 'Database schema audited table for this event is in';

COMMENT ON COLUMN public.logged_actions.table_name
    IS 'Non-schema-qualified table name of table event occured in';

COMMENT ON COLUMN public.logged_actions.relid
    IS 'Table OID. Changes with drop/create. Get with ''tablename''::regclass';

COMMENT ON COLUMN public.logged_actions.session_user_name
    IS 'Login / session user whose statement caused the audited event';

COMMENT ON COLUMN public.logged_actions.action_tstamp_tx
    IS 'Transaction start timestamp for tx in which audited event occurred';

COMMENT ON COLUMN public.logged_actions.action_tstamp_stm
    IS 'Statement start timestamp for tx in which audited event occurred';

COMMENT ON COLUMN public.logged_actions.action_tstamp_clk
    IS 'Wall clock time at which audited event''s trigger call occurred';

COMMENT ON COLUMN public.logged_actions.transaction_id
    IS 'Identifier of transaction that made the change. May wrap, but unique paired with action_tstamp_tx.';

COMMENT ON COLUMN public.logged_actions.application_name
    IS 'Application name set when this audit event occurred. Can be changed in-session by client.';

COMMENT ON COLUMN public.logged_actions.client_addr
    IS 'IP address of client that issued query. Null for unix domain socket.';

COMMENT ON COLUMN public.logged_actions.client_port
    IS 'Remote peer IP port address of client that issued query. Undefined for unix socket.';

COMMENT ON COLUMN public.logged_actions.client_query
    IS 'Top-level query that caused this auditable event. May be more than one statement.';

COMMENT ON COLUMN public.logged_actions.action
    IS 'Action type; I = insert, D = delete, U = update, T = truncate';

COMMENT ON COLUMN public.logged_actions.row_data
    IS 'Record value. Null for statement-level trigger. For INSERT this is the new tuple. For DELETE and UPDATE it is the old tuple.';

COMMENT ON COLUMN public.logged_actions.changed_fields
    IS 'New values of fields changed by UPDATE. Null except for row-level UPDATE events.';

COMMENT ON COLUMN public.logged_actions.statement_only
    IS '''t'' if audit event is from an FOR EACH STATEMENT trigger, ''f'' for FOR EACH ROW';
CREATE INDEX IF NOT EXISTS logged_actions_action_idx
    ON public.logged_actions USING btree
    (action COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS logged_actions_action_tstamp_tx_stm_idx
    ON public.logged_actions USING btree
    (action_tstamp_stm ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS logged_actions_relid_idx
    ON public.logged_actions USING btree
    (relid ASC NULLS LAST)
    TABLESPACE pg_default;


CREATE OR REPLACE FUNCTION public.if_modified_func()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF SECURITY DEFINER
    SET search_path=pg_catalog, public
AS $BODY$
DECLARE
audit_row logged_actions;
include_values boolean;
log_diffs boolean;
h_old hstore;
h_new hstore;
excluded_cols text[] = ARRAY[]::text[];
BEGIN
IF TG_WHEN <> 'AFTER' THEN
RAISE EXCEPTION 'if_modified_func() may only run as an AFTER trigger';
END IF;
audit_row = ROW(
        nextval('logged_actions_id_seq'), -- event_id
        TG_TABLE_SCHEMA::text,                        -- schema_name
        TG_TABLE_NAME::text,                          -- table_name
        TG_RELID,                                     -- relation OID for much quicker searches
        COALESCE(current_setting('cc.usuario', true), current_user),                  -- session_user_name
        COALESCE(current_setting('cc.ci_usuario', true), NULL),       -- ci del usuario logueado
        COALESCE(current_setting('cc.nombre_usuario', true), NULL),       -- nombre completo del usuario logueado
        current_timestamp,                            -- action_tstamp_tx
        statement_timestamp(),                        -- action_tstamp_stm
        clock_timestamp(),                            -- action_tstamp_clk
        txid_current(),                               -- transaction ID
        COALESCE(current_setting('cc.application_name', true), 'PgAdmin IV'), -- client application
        COALESCE(current_setting('cc.ip', true), NULL),                    -- client_addr
        inet_client_port(),                           -- client_port
        current_query(),                              -- top-level query or queries (if multistatement) from client
        substring(TG_OP,1,1),                         -- action
        NULL,                         -- row_data 
        NULL,                                         -- changed_fields
        'f'                                           -- statement_only
        );

IF NOT TG_ARGV[0]::boolean IS DISTINCT FROM 'f'::boolean THEN
audit_row.client_query = NULL;
END IF;

IF TG_ARGV[1] IS NOT NULL THEN
excluded_cols = TG_ARGV[1]::text[];
END IF;

IF (TG_OP = 'UPDATE' AND TG_LEVEL = 'ROW') THEN
audit_row.row_data = hstore(OLD.*) - excluded_cols;
audit_row.changed_fields =  (hstore(NEW.*) - audit_row.row_data) - excluded_cols;
IF audit_row.changed_fields = hstore('') THEN
            -- All changed fields are ignored. Skip this update.
            RETURN NULL;
            END IF;
            ELSIF (TG_OP = 'DELETE' AND TG_LEVEL = 'ROW') THEN
            audit_row.row_data = hstore(OLD.*) - excluded_cols;
            ELSIF (TG_OP = 'INSERT' AND TG_LEVEL = 'ROW') THEN
            audit_row.row_data = hstore(NEW.*) - excluded_cols;
            ELSIF (TG_LEVEL = 'STATEMENT' AND TG_OP IN ('INSERT','UPDATE','DELETE','TRUNCATE')) THEN
            audit_row.statement_only = 't';
            ELSE
            RAISE EXCEPTION '[if_modified_func] - Trigger func added as trigger for unhandled case: %, %',TG_OP, TG_LEVEL;
            RETURN NULL;
            END IF;
            if (TG_OP <> 'SET')  then
            INSERT INTO logged_actions VALUES (audit_row.*);
            end if;
            RETURN NULL;
            END;
            
$BODY$;

ALTER FUNCTION public.if_modified_func()
    OWNER TO postgres;
    
CREATE TABLE IF NOT EXISTS public.user_logs
(
    id serial NOT NULL,
    user_id integer,
    "timestamp" timestamp without time zone DEFAULT now(),
    ip_address character varying(15) COLLATE pg_catalog."default" NOT NULL,
    status_ingreso character varying(15) COLLATE pg_catalog."default" NOT NULL,
    status_salida character varying(15) COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone,
    CONSTRAINT pkey_user_logs_id PRIMARY KEY (id),
    CONSTRAINT user_logs_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.user_logs
    OWNER to postgres;

ALTER TABLE IF EXISTS public.circulos DROP COLUMN IF EXISTS comunidades;

ALTER TABLE IF EXISTS public.circulos
    ADD COLUMN comunidad text COLLATE pg_catalog."default" NOT NULL DEFAULT ''::text;
CREATE OR REPLACE TRIGGER auditar
    AFTER INSERT OR DELETE OR UPDATE 
    ON public.circulos
    FOR EACH ROW
    EXECUTE FUNCTION public.if_modified_func();

CREATE OR REPLACE TRIGGER auditar
    AFTER INSERT OR DELETE OR UPDATE 
    ON public.roles
    FOR EACH ROW
    EXECUTE FUNCTION public.if_modified_func();

CREATE OR REPLACE TRIGGER auditar
    AFTER INSERT OR DELETE OR UPDATE 
    ON public.permissions
    FOR EACH ROW
    EXECUTE FUNCTION public.if_modified_func();

CREATE OR REPLACE TRIGGER auditar
    AFTER INSERT OR DELETE OR UPDATE 
    ON public.role_has_permissions
    FOR EACH ROW
    EXECUTE FUNCTION public.if_modified_func();

CREATE OR REPLACE TRIGGER auditar
    AFTER INSERT OR DELETE OR UPDATE 
    ON public.users
    FOR EACH ROW
    EXECUTE FUNCTION public.if_modified_func();

CREATE OR REPLACE TRIGGER auditar
    AFTER INSERT OR DELETE OR UPDATE 
    ON public.participantes
    FOR EACH ROW
    EXECUTE FUNCTION public.if_modified_func();


CREATE SEQUENCE IF NOT EXISTS public.user_state_id_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 2147483647
    CACHE 1;

ALTER SEQUENCE public.user_state_id_seq
    OWNED BY public.user_state.id;

ALTER SEQUENCE public.user_state_id_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.logged_actions_id_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 2147483647
    CACHE 1;

ALTER SEQUENCE public.logged_actions_id_seq
    OWNED BY public.logged_actions.id;

ALTER SEQUENCE public.logged_actions_id_seq
    OWNER TO postgres;
CREATE SEQUENCE IF NOT EXISTS public.user_logs_id_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 2147483647
    CACHE 1;

ALTER SEQUENCE public.user_logs_id_seq
    OWNED BY public.user_logs.id;

ALTER SEQUENCE public.user_logs_id_seq
    OWNER TO postgres;
CREATE OR REPLACE VIEW public.vcirculos_dia
 AS
 SELECT date_trunc('day'::text, created_at)::date AS fecha,
    count(*) AS total_registros
   FROM circulos
  GROUP BY (date_trunc('day'::text, created_at))
  ORDER BY (date_trunc('day'::text, created_at)::date);

ALTER TABLE public.vcirculos_dia
    OWNER TO postgres;


CREATE OR REPLACE VIEW public.vcirculos_mes
 AS
 SELECT EXTRACT(month FROM date_trunc('month'::text, created_at)) AS mes,
    count(*) AS total_registros
   FROM circulos
  GROUP BY (EXTRACT(month FROM date_trunc('month'::text, created_at)))
  ORDER BY (EXTRACT(month FROM date_trunc('month'::text, created_at))) DESC;

ALTER TABLE public.vcirculos_mes
    OWNER TO postgres;


CREATE OR REPLACE VIEW public.vcirculos_user_dia
 AS
 SELECT b.name,
    date_trunc('day'::text, a.created_at)::date AS fecha,
    count(a.*) AS total_registros
   FROM circulos a
     LEFT JOIN users b ON b.id = a.user_id
  GROUP BY b.name, (date_trunc('day'::text, a.created_at))
  ORDER BY b.name, (date_trunc('day'::text, a.created_at)::date);

ALTER TABLE public.vcirculos_user_dia
    OWNER TO postgres;


CREATE OR REPLACE VIEW public.vcirculos_user_mes
 AS
 SELECT b.name,
    EXTRACT(month FROM date_trunc('month'::text, a.created_at)) AS mes,
    count(a.*) AS total_registros
   FROM circulos a
     LEFT JOIN users b ON b.id = a.user_id
  GROUP BY b.name, (EXTRACT(month FROM date_trunc('month'::text, a.created_at)))
  ORDER BY b.name, (EXTRACT(month FROM date_trunc('month'::text, a.created_at)));

ALTER TABLE public.vcirculos_user_mes
    OWNER TO postgres;


CREATE OR REPLACE VIEW public.vparticipantes_user_dia
 AS
 SELECT b.name,
    date_trunc('day'::text, a.created_at)::date AS fecha,
    count(a.*) AS total_registros
   FROM participantes a
     LEFT JOIN users b ON b.id = a.user_id
  GROUP BY b.name, (date_trunc('day'::text, a.created_at))
  ORDER BY b.name, (date_trunc('day'::text, a.created_at)::date);

ALTER TABLE public.vparticipantes_user_dia
    OWNER TO postgres;


CREATE OR REPLACE VIEW public.vparticipantes_user_mes
 AS
 SELECT b.name,
    EXTRACT(month FROM date_trunc('month'::text, a.created_at)) AS mes,
    count(a.*) AS total_registros
   FROM participantes a
     LEFT JOIN users b ON b.id = a.user_id
  GROUP BY b.name, (EXTRACT(month FROM date_trunc('month'::text, a.created_at)))
  ORDER BY b.name, (EXTRACT(month FROM date_trunc('month'::text, a.created_at)));

ALTER TABLE public.vparticipantes_user_mes
    OWNER TO postgres;


CREATE OR REPLACE VIEW public.vparticipantes_dia
 AS
 SELECT date_trunc('day'::text, created_at)::date AS fecha,
    count(*) AS total_registros
   FROM participantes
  GROUP BY (date_trunc('day'::text, created_at))
  ORDER BY (date_trunc('day'::text, created_at)::date);

ALTER TABLE public.vparticipantes_dia
    OWNER TO postgres;


CREATE OR REPLACE VIEW public.vuser_logs
 AS
 SELECT b.email,
    b.name,
    to_char(a."timestamp", 'YYYY-MM-DD HH24:MI:SS'::text) AS fecha_hora,
    a.ip_address,
    a.status_ingreso,
    a.status_salida
   FROM user_logs a
     LEFT JOIN users b ON b.id = a.user_id;

ALTER TABLE public.vuser_logs
    OWNER TO postgres;


CREATE OR REPLACE VIEW public.vparticipantes_mes
 AS
 SELECT EXTRACT(month FROM date_trunc('month'::text, created_at)) AS mes,
    count(*) AS total_registros
   FROM participantes
  GROUP BY (EXTRACT(month FROM date_trunc('month'::text, created_at)))
  ORDER BY (EXTRACT(month FROM date_trunc('month'::text, created_at))) DESC;

ALTER TABLE public.vparticipantes_mes
    OWNER TO postgres;



-- Changing the columns in a view requires dropping and re-creating the view.
-- This may fail if other objects are dependent upon this view,
-- or may cause procedural functions to fail if they are not modified to
-- take account of the changes.
DROP VIEW public.vcirculos;

CREATE OR REPLACE VIEW public.vcirculos
    AS
     SELECT a.id,
    a.estado_id,
    b.estado,
    a.municipio_id,
    c.municipio,
    a.parroquia_id,
    d.parroquia,
    a.comunidad,
    a.circulo,
    a.user_id AS usuario_id,
    e.name AS usuario,
    a.created_at
   FROM circulos a
     LEFT JOIN cne_estados b ON b.estado_id = a.estado_id
     LEFT JOIN cne_municipios c ON c.municipio_id = a.municipio_id
     LEFT JOIN cne_parroquias d ON d.parroquia_id = a.parroquia_id
     LEFT JOIN users e ON e.id = a.user_id
  WHERE a.deleted_at IS NULL
  ORDER BY b.estado, c.municipio, d.parroquia, a.circulo;

ALTER TABLE public.vcirculos
    OWNER TO postgres;


 -- END;